# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/21_sureau_core_veg.ipynb.

# %% auto 0
__all__ = ['new_sureau_veg', 'compute_pheno_sureau_veg', 'update_capacitances_apo_and_sym_sureau_veg',
           'update_lai_and_stocks_sureau_veg', 'compute_interception_sureau_veg', 'compute_water_storage_sureau_veg',
           'compute_evapo_intercepted_sureau_veg', 'update_kplant_sureau_veg', 'compute_transpiration_sureau_veg']

# %% ../nbs/21_sureau_core_veg.ipynb 3
import collections
import numpy as np
from typing import Dict
from sureau_ecos_py.plant_utils import (
    plc_comp,
    rs_comp,
    compute_dfmc,
    k_series_sum,
    compute_tleaf,
    calculate_ebound_granier,
)

from sureau_ecos_py.create_vegetation_parameters import (
    create_vegetation_parameters,
)
from .create_modeling_options import create_modeling_options
from .create_soil_parameters import create_soil_parameters
from .create_stand_parameters import create_stand_parameters

# %% ../nbs/21_sureau_core_veg.ipynb 4
def new_sureau_veg(
    veg_params: Dict,  # Dictionary created using the `create_vegetation_parameters` function
) -> Dict:
    'Create an object sureau_veg from veg_params'

    # Assert parameters ---------------------------------------------------------
    assert isinstance(
        veg_params, Dict
    ), f'veg_param must be a Dictionary not a {type(veg_params)}'

    # Add params to sureau_veg dictionary ---------------------------------------

    # Create Empty dict
    sureau_veg = collections.defaultdict(list)

    # Add veg_params
    sureau_veg['params'] = veg_params

    # Add Stem and Leaf turgor point
    sureau_veg['params']['psi_tlp_leaf'] = (
        sureau_veg['params']['pifullturgor_leaf']
        * sureau_veg['params']['epsilonsym_leaf']
        / (
            sureau_veg['params']['pifullturgor_leaf']
            + sureau_veg['params']['epsilonsym_leaf']
        )
    )
    sureau_veg['params']['psi_tlp_stem'] = (
        sureau_veg['params']['pifullturgor_stem']
        * sureau_veg['params']['epsilonsym_stem']
        / (
            sureau_veg['params']['pifullturgor_stem']
            + sureau_veg['params']['epsilonsym_stem']
        )
    )

    # Add potentials
    sureau_veg['psi_lapo'] = 0
    sureau_veg['psi_sapo'] = 0
    sureau_veg['psi_lsym'] = 0
    sureau_veg['psi_ssym'] = 0

    # FP replaced "mem" by "cav" (when cavitation starts)
    sureau_veg['psi_lapo_cav'] = 0
    sureau_veg['psi_sapo_cav'] = 0
    sureau_veg['psi_all_soil'] = 0

    # Conductance & capacitance (mmol/m2/s/MPa) Here on leaf area basis but they
    # are to be updated as a function symplasm conductance and leaf area hydraulic
    # conductances

    # constant value during simulation
    sureau_veg['k_plant'] = sureau_veg['params']['k_plant_init']

    # constant value during simulation
    sureau_veg['k_lsym'] = sureau_veg['params']['k_lsym_init']

    # constant value during simulation
    sureau_veg['k_ssym'] = sureau_veg['params']['k_ssyminit']

    # Value is updated in compute_kplant_sureau_veg
    sureau_veg['k_rsapo'] = np.nan

    # Value is updated in compute_kplant_sureau_veg
    sureau_veg['k_slapo'] = np.nan

    # Conductance rhisophere for each soil layer
    sureau_veg['k_soil_to_stem'] = np.array([np.nan, np.nan, np.nan], dtype=float)

    # Capacitances
    # Symplasm capacitance updated as a function of water content and Leaf area
    # (mmol/m2leaf/MPa) /updated in update.capacitancesSymAndApo()
    # (NM : 25/10/2021)

    sureau_veg['c_lsym'] = np.nan
    sureau_veg['c_sapo'] = np.nan

    # Leaf and canopy conductance

    # initialised at 0 to compute Tleaf on first time step considering gs = 0
    # and not NA s
    sureau_veg['gmin'] = 0

    # Gmin for stem and branches
    sureau_veg['gmin_s'] = sureau_veg['params']['gmin_s']

    # TODO voir si y'a besoin d'initialiser
    # see if there is a need to initialize

    sureau_veg['regul_fact'] = 0.01

    # TODO voir pour mettre tout en NA si TranspirationMod = 0
    # see to put everything in NA if TranspirationMod = 0

    sureau_veg['gs_bound'] = np.nan

    # initialised to 0 to compute Tleaf on first time step considering gs = 0
    # and not NA
    sureau_veg['gs_lim'] = 0
    sureau_veg['gcanopy_bound'] = np.nan
    sureau_veg['gcanopy_lim'] = np.nan
    sureau_veg['g_bl'] = np.nan
    sureau_veg['g_crown'] = np.nan

    # Fluxes
    sureau_veg['e_prime'] = 0
    sureau_veg['e_min'] = 0
    sureau_veg['e_min_s'] = 0
    sureau_veg['e_bound'] = 0
    sureau_veg['e_lim'] = 0
    sureau_veg['flux_soil_to_stem'] = np.zeros(3)
    sureau_veg['transpiration_mm'] = 0
    sureau_veg['e_min_mm'] = 0
    sureau_veg['e_min_s_mm'] = 0

    # LAI and LAI-dependent variables
    sureau_veg['lai_pheno'] = np.zeros(1)
    sureau_veg['lai'] = np.zeros(1)
    sureau_veg['canopy_storage_capacity'] = np.zeros(1)

    # rainfall and interception

    # precipitation (ppt) that reach the soil
    sureau_veg['ppt_soil'] = 0

    # interceptedWater /quantite d'eau dans la canopee
    sureau_veg['intercepted_water_amount'] = 0
    sureau_veg['evaporation_intercepted'] = 0
    sureau_veg['petr'] = 0

    # defoliation // no defoliation (add an option to set defoliation due to
    # cavitation of the Plant Above)
    sureau_veg['defoliation'] = 0
    sureau_veg['lai_dead'] = 0

    # Cavitation
    # percent loss of conductivity in the leaf [%]
    sureau_veg['plc_leaf'] = 0

    # percent loss of conductivity in the stem [%]
    sureau_veg['plc_stem'] = 0

    # leaf temp
    sureau_veg['leaf_temperature'] = np.nan

    # Pheno, parameters if deciduous
    if sureau_veg['params']['foliage'] == 'deciduous':
        sureau_veg['lai_pheno'] = 0

        # temmpeerature sum to determine budburst
        sureau_veg['sum_temperature'] = 0

        # budburst date
        sureau_veg['bud_burst_date'] = np.nan

        print('sureau_veg params for deciduous forest created')
    else:
        print(f'sureau_veg params for {sureau_veg["params"]["foliage"]} created')

    # water storage in canopy

    # Fuel moisture content of the dead compartment (gH20/gMS)
    sureau_veg['dfmc'] = np.nan

    # Live fuel moisture content of the apoplasmic compartment (gH20/gMS)
    sureau_veg['lfmc_apo'] = np.nan

    # Live fuel moisture content of the apoplasmic compartment (gH20/gMS)
    sureau_veg['lfmc_symp'] = np.nan

    # live fuel moisture content (gH20/gMS)
    sureau_veg['lfmc'] = np.nan

    # Live Canopy dry matter [gMS/m2 soil]
    sureau_veg['dm_live_canopy'] = np.nan

    # Dead Canopy dry matter [gMS/m2 soil]
    sureau_veg['dm_dead_canopy'] = 0

    # Q leaf apo (mol/m2leaf)
    sureau_veg['q_lapo_sat_mmol'] = 0
    sureau_veg['q_lapo_sat_l'] = 0

    # Q stem apo (mol/m2leaf)
    sureau_veg['q_sapo_sat_mmol'] = 0
    sureau_veg['q_sapo_sat_l'] = 0

    # Q leaf symplasm (mol/m2leaf)
    sureau_veg['q_lsym_sat_mmol'] = 0
    sureau_veg['q_lsym_sat_l'] = 0

    # Q Stem symplasm (mol/m2leaf)
    sureau_veg['q_ssym_sat_mmol'] = 0
    sureau_veg['q_ssym_sat_l'] = 0

    # Q Stem and Leaf apo and symp in liter/kg TODO 13/08/2021: better in mmol?
    sureau_veg['q_lapo_l'] = 0
    sureau_veg['q_sapo_l'] = 0
    sureau_veg['q_lsym_l'] = 0
    sureau_veg['q_ssym_l'] = 0

    sureau_veg['delta_q_lapo_mmol_diag'] = 0

    # Water from the cavitated part, term from equations 6 and 7 in the
    # SurEau-Ecos paper
    sureau_veg['f_l_cav'] = 0
    sureau_veg['f_s_cav'] = 0

    # Compute PLC

    # Leaf
    sureau_veg['plc_leaf'] = plc_comp(
        psi=sureau_veg['psi_lapo'],
        slope=sureau_veg['params']['slope_vc_leaf'],
        p50=sureau_veg['params']['p50_vc_leaf'],
    )
    # Stem
    sureau_veg['plc_stem'] = plc_comp(
        psi=sureau_veg['psi_sapo'],
        slope=sureau_veg['params']['slope_vc_stem'],
        p50=sureau_veg['params']['p50_vc_stem'],
    )

    return sureau_veg

# %% ../nbs/21_sureau_core_veg.ipynb 11
def compute_pheno_sureau_veg(
    sureau_veg: Dict,  # Dictionary created using the `new_sureau_veg` function
    temperature: float,  # daily tempeature  (degC)
    day_of_year: int,
) -> Dict:
    'Compute phenology and leaf area index (lai) for sureau_veg dictionary in sureau_ecos_py'
    # Assert parameters ---------------------------------------------------------

    # sureau_veg
    assert isinstance(
        sureau_veg, Dict
    ), f'sureau_veg must be a Dictionary not a {type(sureau_veg)}'

    # Temperature
    assert (
        -40 <= temperature <= 70
    ), 'Unrealistic air temperature, value must be a value between -40 and 70'

    # Day of year
    assert (
        isinstance(day_of_year, int) and 366 >= day_of_year >= 1
    ), 'day_of_year must be a integer value between 1-366'

    # Set to initial parameters at the beggining of the year --------------------
    if day_of_year == 1:
        print(
            f'Setting initial parameters at the beggining of the year (day number:{day_of_year})'
        )

        if sureau_veg['params']['foliage'] == 'evergreen':
            sureau_veg['lai_pheno'] = sureau_veg['params']['lai_max']

        elif sureau_veg['params']['foliage'] == 'deciduous':
            sureau_veg['lai_pheno'] = 0
            sureau_veg['sum_temperature'] = 0
            sureau_veg['bud_burst_date'] = np.nan

        elif sureau_veg['params']['foliage'] == 'forced':
            sureau_veg['lai_pheno'] = 0
            sureau_veg['sum_temperature'] = 0
            sureau_veg['bud_burst_date'] = np.nan

        else:
            raise ValueError(
                'Error in setting initial parameters in compute_pheno_sureau_veg function'
            )

    # Setting parameters for deciduous vegetation -------------------------------
    if sureau_veg['params']['foliage'] == 'deciduous':
        # if no budburst
        if np.isnan(sureau_veg['bud_burst_date']):
            if (
                temperature > sureau_veg['params']['t_base']
                and day_of_year >= sureau_veg['params']['day_start']
            ):
                # Update sum_temperature if temp > t_base
                sureau_veg['sum_temperature'] = (
                    sureau_veg['sum_temperature'] + temperature
                )

            elif sureau_veg['sum_temperature'] > sureau_veg['params']['f_crit']:
                sureau_veg['bud_burst_date'] = day_of_year

            else:
                raise ValueError(
                    'Error setting sum_temperature for deciduous vegetation in compute_pheno_sureau_veg function'
                )

        # loss of leaves on day 270
        elif day_of_year >= 280:
            sureau_veg['lai_pheno'] = np.maximum(
                0,
                sureau_veg['lai']
                - np.maximum(
                    0,
                    sureau_veg['params']['lai_max'] / sureau_veg['params']['nbday_lai'],
                ),
            )

        elif np.isnan(sureau_veg['bud_burst_date']) is False:
            # if bud break and leaf construction period
            if (
                day_of_year
                < sureau_veg['bud_burst_date'] + sureau_veg['params']['nbday_lai']
            ):
                sureau_veg['lai_pheno'] = sureau_veg['lai_pheno'] + np.maximum(
                    0,
                    sureau_veg['params']['lai_max'] / sureau_veg['params']['nbday_lai'],
                )

            else:
                raise ValueError(
                    'Error setting lai_pheno for deciduous vegetation in compute_pheno_sureau_veg function'
                )

        else:
            raise ValueError(
                'Error setting parameters for deciduous vegetation in compute_pheno_sureau_veg function'
            )

    # Setting parameters for forced vegetation ----------------------------------
    if sureau_veg['params']['foliage'] == 'forced':
        # No bud_burst_date
        if np.isnan(sureau_veg['bud_burst_date']):
            if day_of_year >= sureau_veg['params']['day_start_forced']:
                sureau_veg['bud_burst_date'] = day_of_year

            else:
                raise ValueError(
                    'Error setting bud_burst_date for forced vegetation in compute_pheno_sureau_veg function'
                )

        #  Leaf shedding
        elif day_of_year >= sureau_veg['params']['day_end_forced']:
            sureau_veg['lai_pheno'] = np.maximum(
                0,
                sureau_veg['lai']
                - np.maximum(
                    0,
                    sureau_veg['params']['lai_max'] / sureau_veg['params']['nbday_lai'],
                ),
            )

        elif np.isnan(sureau_veg['bud_burst_date']) is False:
            # After bud burst and before full LAI
            if (
                day_of_year
                < sureau_veg['bud_burst_date'] + sureau_veg['params']['nbday_lai']
            ):
                sureau_veg['lai_pheno'] = sureau_veg['lai_pheno'] + np.maximum(
                    0,
                    sureau_veg['params']['lai_max'] / sureau_veg['params']['nbday_lai'],
                )

            else:
                raise ValueError(
                    'Error setting lai_pheno for forced vegetation in compute_pheno_sureau_veg function'
                )

        else:
            raise ValueError(
                'Error setting parameters for forced vegetation in compute_pheno_sureau_veg function'
            )

    return sureau_veg

# %% ../nbs/21_sureau_core_veg.ipynb 19
def update_capacitances_apo_and_sym_sureau_veg(
    sureau_veg: Dict,  # Dictionary created using the `new_sureau_veg` function
) -> Dict:
    'Update symplasmic plant capacitances for trunk and leaves'

    # Assert parameters ---------------------------------------------------------
    # sureau_veg
    assert isinstance(
        sureau_veg, Dict
    ), f'sureau_veg must be a Dictionary not a {type(sureau_veg)}'

    # NM minimal double to avoid-INF --------------------------------------------
    dbxmin = 1e-100

    # Compute the relative water content of the symplasm ------------------------
    rwc_lsym = 1 - rs_comp(
        pi_ft=sureau_veg['params']['pifullturgor_leaf'],
        e_symp=sureau_veg['params']['epsilonsym_leaf'],
        psi=sureau_veg['psi_lsym'] - dbxmin,
    )
    # Compute the derivative of the relative water content of the symplasm
    if sureau_veg['psi_lsym'] > sureau_veg['params']['psi_tlp_leaf']:
        # FP derivative of -Pi0- Eps(1-RWC)+Pi0/RWC
        rwc_lsym_prime = rwc_lsym / (
            -sureau_veg['params']['pifullturgor_leaf']
            - sureau_veg['psi_lsym']
            - sureau_veg['params']['epsilonsym_leaf']
            + 2 * sureau_veg['params']['epsilonsym_leaf'] * rwc_lsym
        )

    else:
        # FP derivative of Pi0/Psi
        rwc_lsym_prime = (
            -sureau_veg['params']['pifullturgor_leaf'] / sureau_veg['psi_lsym'] ** 2
        )

    # Compute the leaf capacitance (mmol/MPa/m2_sol)
    if sureau_veg['lai'] == 0:
        sureau_veg['c_lsym'] = 0

    else:
        sureau_veg['c_lsym'] = (
            sureau_veg['q_lsym_sat_mmol_per_leaf_area'] * rwc_lsym_prime
        )

    # Stem symplasmic canopy water content --------------------------------------
    rwc_ssym = 1 - rs_comp(
        pi_ft=sureau_veg['params']['pifullturgor_stem'],
        e_symp=sureau_veg['params']['epsilonsym_stem'],
        psi=sureau_veg['psi_ssym'] - dbxmin,
    )

    # Compute the derivative of the relative water content of the symplasm
    if sureau_veg['psi_ssym'] > sureau_veg['params']['psi_tlp_stem']:
        # FP derivative of -Pi0- Eps(1-RWC)+Pi0/RWC
        rwc_ssym_prime = rwc_ssym / (
            -sureau_veg['params']['pifullturgor_stem']
            - sureau_veg['psi_ssym']
            - sureau_veg['params']['epsilonsym_stem']
            + 2 * sureau_veg['params']['epsilonsym_stem'] * rwc_ssym
        )

    else:
        # FP derivative of Pi0/Psi
        rwc_ssym_prime = (
            -sureau_veg['params']['pifullturgor_stem'] / sureau_veg['psi_ssym'] ** 2
        )

    # Compute the capacitance (mmol/MPa/m2_leaf)
    # Stem capacitance per leaf area can only decrease with LAI
    # (cannot increase when LAI<1 )
    sureau_veg['c_ssym'] = sureau_veg['q_ssym_sat_mmol_per_leaf_area'] * rwc_ssym_prime

    # Add c_sapo and c_lapo -----------------------------------------------------
    sureau_veg['c_sapo'] = sureau_veg['params']['c_sapoinit']
    sureau_veg['c_lapo'] = sureau_veg['params']['c_lapoinit']

    return sureau_veg

# %% ../nbs/21_sureau_core_veg.ipynb 20
def update_lai_and_stocks_sureau_veg(
    sureau_veg: Dict,  # Dictionary created using the `new_sureau_veg` function
    modeling_options: Dict,  # Dictionary created using the `create_modeling_options` function
) -> Dict:
    'Update leaf area index (LAI) as a function of lai_pheno and caviation and update LAI dependent parameters'

    # Assert parameters ---------------------------------------------------------

    # sureau_veg
    assert isinstance(
        sureau_veg, Dict
    ), f'sureau_veg must be a Dictionary not a {type(sureau_veg)}'

    # Make sure that modeling_options is a dictionary
    assert isinstance(
        modeling_options, Dict
    ), f'modeling_options must be a dictionary not a {type(modeling_options)}'

    # Set lai_dead parameter ----------------------------------------------------

    # Cavitation does not affect LAI
    if modeling_options['defoliation'] is False:
        sureau_veg['lai_dead'] = 0

    # Cavitation does affect LAI
    elif modeling_options['defoliation'] is True:
        # Leaf shedding because of cavitation. Starts only if PLCabove > 10%
        if sureau_veg['plc_leaf'] > 10:
            sureau_veg['lai_dead'] = np.maximum(
                0, sureau_veg['lai_pheno'] * sureau_veg['plc_leaf'] / 100
            )

        else:
            sureau_veg['lai_dead'] = 0
    else:
        raise ValueError(
            'Error setting lai_dead in update_lai_and_stocks_sureau_veg function'
        )

    # Update lai ----------------------------------------------------------------
    sureau_veg['lai'] = sureau_veg['lai_pheno'] - sureau_veg['lai_dead']

    # Update LAI-dependent variables --------------------------------------------
    sureau_veg['fcc'] = 1 - np.exp(-sureau_veg['params']['k'] * sureau_veg['lai'])
    sureau_veg['canopy_storage_capacity'] = 1.5 * sureau_veg['lai']

    # Update water storing capacities of the dead and living canopy -------------
    # Water storing capacities of the living component
    sureau_veg['dm_live_canopy'] = sureau_veg['lai'] * sureau_veg['params']['lma']

    # water storing capacities of the dead component
    sureau_veg['dm_dead_canopy'] = sureau_veg['lai_dead'] * sureau_veg['params']['lma']

    # Calculate symplastic water content ----------------------------------------

    # Leaf symplastic water content in l/m2 (i.e. mm)
    sureau_veg['q_lsym_sat_l'] = (
        (1 / (sureau_veg['params']['ldmc'] / 1000) - 1)
        * sureau_veg['dm_live_canopy']
        * (1 - sureau_veg['params']['apofrac_leaf'])
        / 1000
    )

    sureau_veg['q_lsym_sat_mmol'] = sureau_veg['q_lsym_sat_l'] * 1000000 / 18

    # Calculate q_lsym_sat_mmol_per_leaf_area
    if sureau_veg['lai'] == 0:
        sureau_veg['q_lsym_sat_mmol_per_leaf_area'] = 0

    else:
        sureau_veg['q_lsym_sat_mmol_per_leaf_area'] = sureau_veg[
            'q_lsym_sat_mmol'
        ] / np.maximum(1, sureau_veg['lai'])

    # Stem symplastic water content in l/m2 (i.e. mm)
    sureau_veg['q_ssym_sat_l'] = (
        sureau_veg['params']['vol_stem'] * sureau_veg['params']['symfrac_stem']
    )

    sureau_veg['q_ssym_sat_mmol'] = sureau_veg['q_ssym_sat_l'] * 1000000 / 18

    # used max(1,LAI) to avoid that Q_SSym_sat_mmol_perLeafArea--> inF when
    # LAI --> 0 (limit imposed by computing water fluxes by m2leaf)
    sureau_veg['q_ssym_sat_mmol_per_leaf_area'] = sureau_veg[
        'q_ssym_sat_mmol'
    ] / np.maximum(1, sureau_veg['lai'])

    # Calculate apoplastic water content ----------------------------------------
    # Leaf apoplastic water content in l/m2 (i.e. mm)
    sureau_veg['q_lapo_sat_l'] = (
        (1 / (sureau_veg['params']['ldmc'] / 1000) - 1)
        * sureau_veg['dm_live_canopy']
        * (sureau_veg['params']['apofrac_leaf'])
        / 1000
    )

    sureau_veg['q_lapo_sat_mmol'] = sureau_veg['q_lapo_sat_l'] * 1000000 / 18

    # Calculate q_lsym_sat_mmol_per_leaf_area
    if sureau_veg['lai'] == 0:
        sureau_veg['q_lapo_sat_mmol_per_leaf_area'] = 0

    else:
        sureau_veg['q_lapo_sat_mmol_per_leaf_area'] = sureau_veg[
            'q_lapo_sat_mmol'
        ] / np.maximum(1, sureau_veg['lai'])

    # Stem apoplastic water content in l/m2 (i.e. mm)
    sureau_veg['q_sapo_sat_l'] = (
        sureau_veg['params']['vol_stem'] * sureau_veg['params']['apofrac_stem']
    )

    sureau_veg['q_sapo_sat_mmol'] = sureau_veg['q_sapo_sat_l'] * 1000000 / 18

    # Used max(1,LAI) to avoid that Q_SApo_sat_mmol_perLeafArea--> inF when
    # LAI --> 0 (limit imposed by computing water fluxes by m2leaf)
    sureau_veg['q_s_sat_mmol_per_leaf_area'] = sureau_veg[
        'q_sapo_sat_mmol'
    ] / np.maximum(1, sureau_veg['lai'])

    return update_capacitances_apo_and_sym_sureau_veg(sureau_veg)

# %% ../nbs/21_sureau_core_veg.ipynb 23
def compute_interception_sureau_veg(
    sureau_veg: Dict,  # Dictionary created using the `new_sureau_veg` function
    ppt: float,  # precipitation (mm) that reach the soil
) -> Dict:
    'Rain interception by canopy/stock of water in the canopy reservoir (one vegetation layer only)'

    # Assert parameters ---------------------------------------------------------

    # sureau_veg
    assert isinstance(
        sureau_veg, Dict
    ), f'sureau_veg must be a Dictionary not a {type(sureau_veg)}'

    assert isinstance(ppt, float) or isinstance(
        ppt, int
    ), 'Precipitation must be a numeric value'

    # Calculate intercepted water amount ----------------------------------------

    # No overflow
    if ppt * sureau_veg['fcc'] <= (
        sureau_veg['canopy_storage_capacity'] - sureau_veg['intercepted_water_amount']
    ):
        sureau_veg['ppt_soil'] = ppt * (1 - sureau_veg['fcc'])
        sureau_veg['intercepted_water_amount'] = sureau_veg[
            'intercepted_water_amount'
        ] + (ppt * sureau_veg['fcc'])

    # Overflow
    elif ppt * sureau_veg['fcc'] > (
        sureau_veg['canopy_storage_capacity'] - sureau_veg['intercepted_water_amount']
    ):
        sureau_veg['ppt_soil'] = ppt - (
            sureau_veg['canopy_storage_capacity']
            - sureau_veg['intercepted_water_amount']
        )
        sureau_veg['intercepted_water_amount'] = sureau_veg['canopy_storage_capacity']

    else:
        raise ValueError(
            'Error calculating intercepted water amount in compute_interception_sureau_veg function'
        )

    return sureau_veg

# %% ../nbs/21_sureau_core_veg.ipynb 26
def compute_water_storage_sureau_veg(
    sureau_veg: Dict,  # Dictionary created using the `new_sureau_veg` function
    vpd: float,  # Vapor Pressure Deficit (kPa)
) -> Dict:
    'Compute water stocks in leaves/wood in SUREAU_ECOS (one vegetation layer only)'

    # Assert parameters ---------------------------------------------------------

    # sureau_veg
    assert isinstance(
        sureau_veg, Dict
    ), f'sureau_veg must be a Dictionary not a {type(sureau_veg)}'

    assert isinstance(vpd, float) or isinstance(
        vpd, int
    ), 'VPD must be a numeric value'

    # Symplasmic canopy water content of the leaves -----------------------------

    # Relative water content (unitless)
    rwc_lsym = 1 - rs_comp(
        pi_ft=sureau_veg['params']['pifullturgor_leaf'],
        e_symp=sureau_veg['params']['epsilonsym_leaf'],
        psi=sureau_veg['psi_lsym'],
    )

    q_lsym = np.maximum(0, rwc_lsym) * sureau_veg['q_lsym_sat_l']
    sureau_veg['q_lsym_l'] = q_lsym
    sureau_veg['lfmc_symp'] = 100 * (
        q_lsym
        / (
            sureau_veg['dm_live_canopy']
            * (1 - sureau_veg['params']['apofrac_leaf'])
            / 1000
        )
    )

    # Apoplasmic water content of the leaves ------------------------------------
    q_lapo = (1 - sureau_veg['plc_leaf'] / 100) * sureau_veg['q_lapo_sat_l']
    sureau_veg['q_lapo_l'] = q_lapo

    #  LFMC of Apo (relative moisture content to dry mass), gH20/gMS
    sureau_veg['lfmc_apo'] = 100 * (
        q_lapo
        / (sureau_veg['dm_live_canopy'] * sureau_veg['params']['apofrac_leaf'] / 1000)
    )

    # LFMC leaf total (Apo+Symp) ------------------------------------------------
    sureau_veg['lfmc'] = 100 * (q_lapo + q_lsym) / (sureau_veg['dm_live_canopy'] / 1000)

    # Symplasmic canopy water content of the stem -------------------------------
    # Relative water content (unitless)
    rwc_ssym = 1 - rs_comp(
        pi_ft=sureau_veg['params']['pifullturgor_stem'],
        e_symp=sureau_veg['params']['epsilonsym_stem'],
        psi=sureau_veg['psi_ssym'],
    )

    q_ssym = np.maximum(0, rwc_ssym) * sureau_veg['q_ssym_sat_l']
    sureau_veg['q_ssym_l'] = q_ssym

    # Apoplasmic water content of the stem --------------------------------------
    q_sapo = (1 - sureau_veg['plc_stem'] / 100) * sureau_veg['q_sapo_sat_l']
    sureau_veg['q_sapo_l'] = q_sapo

    # FMC canopy ----------------------------------------------------------------
    # Dead FMC [%]
    sureau_veg['dfmc'] < -compute_dfmc(vpd)

    # Water quantity of dead foliage (l/m2 sol ou mm)
    q_ldead = (sureau_veg['dfmc'] / 100) * sureau_veg['dm_dead_canopy'] / 1000
    sureau_veg['fmc_canopy'] = (
        100
        * (q_lapo + q_lsym + q_ldead)
        / (sureau_veg['dm_live_canopy'] / 1000 + sureau_veg['dm_dead_canopy'] / 1000)
    )

    return sureau_veg

# %% ../nbs/21_sureau_core_veg.ipynb 28
def compute_evapo_intercepted_sureau_veg(
    sureau_veg: Dict,  # Dictionary created using the `new_sureau_veg` function
    pet: float,  # Potential evapotranspiration
) -> Dict:
    'Compute evaporation of the water intercepted by the canopy in the SUREAU_ECOS model'

    # Assert parameters ---------------------------------------------------------

    # sureau_veg
    assert isinstance(
        sureau_veg, Dict
    ), f'sureau_veg must be a Dictionary not a {type(sureau_veg)}'

    assert isinstance(pet, float) or isinstance(
        pet, int
    ), 'pet must be a numeric value'

    # Calculate PETr and evaporation intercepted --------------------------------
    if pet >= 0:
        if pet >= sureau_veg['intercepted_water_amount']:
            sureau_veg['petr'] = sureau_veg['intercepted_water_amount'] - pet
            sureau_veg['evaporation_intercepted'] = (
                sureau_veg['intercepted_water_amount'] - pet
            )

        # empty the reservoir
        sureau_veg['qr'] = 0

    # Energy not sufficient to evaporate the intercepted water
    elif pet < sureau_veg['qr']:
        sureau_veg['intercepted_water_amount'] = (
            sureau_veg['intercepted_water_amount'] - pet
        )
        sureau_veg['petr'] = 0
        sureau_veg['evaporation_intercepted'] = (
            sureau_veg['intercepted_water_amount'] - pet
        )

    else:
        raise ValueError(
            'Error calculating PETr and evaporation intercepted in compute_evapo_intercepted_sureau_veg function'
        )

    return sureau_veg

# %% ../nbs/21_sureau_core_veg.ipynb 30
def update_kplant_sureau_veg(
    sureau_veg: Dict,  # Dictionary created using the `new_sureau_veg` function
    sureau_soil: Dict,  # Missing definition
) -> Dict:
    'Update whole plant conductance (kplant) for sureau_veg dictionary'

    # Assert parameters ---------------------------------------------------------

    # sureau_veg
    assert isinstance(
        sureau_veg, Dict
    ), f'sureau_veg must be a Dictionary not a {type(sureau_veg)}'

    # sureau_soil
    assert isinstance(
        sureau_soil, Dict
    ), f'sureau_soil must be a Dictionary not a {type(sureau_soil)}'

    # Calculate k_RSApo and k_SLApo with cavitation -----------------------------
    sureau_veg['k_rsapo'] = sureau_veg['params']['k_rsapo_init'] * (
        1 - sureau_veg['plc_stem'] / 100
    )
    sureau_veg['k_slapo'] = sureau_veg['params']['k_slapo_init'] * (
        1 - sureau_veg['plc_leaf'] / 100
    )

    # Root from root length -----------------------------------------------------
    # conductance from soil to collar (two resistances in series Rsoil and Rroot)
    sureau_veg['k_soil_to_stem'] = k_series_sum(sureau_soil['k_soil'], sureau_veg['k_rsapo'])

    # Compute k_plant (from root to leaf) for diagnostic only -------------------
    sureau_veg['k_plant'] = 1 / (
        1 / sum(sureau_veg['k_rsapo']) + 1 / sureau_veg['k_slapo'] + 1 / sureau_veg['k_lsym']
    )

    return sureau_veg

# %% ../nbs/21_sureau_core_veg.ipynb 32
def compute_transpiration_sureau_veg(
    sureau_veg: Dict,  # Dictionary created using the `new_sureau_veg` function
    sureau_clim: Dict,  # Dictionary created using the `new_sureau_clim` function
    modeling_options: Dict,  # Dictionary created using the `create_modeling_options` function
    nhours: int,  # Array showing the difference between each time step
) -> Dict:
    # Assert parameters ---------------------------------------------------------

    # sureau_veg
    assert isinstance(
        sureau_veg, Dict
    ), f'sureau_veg must be a Dictionary not a {type(sureau_veg)}'

    # sureau_soil
    assert isinstance(
        sureau_clim, Dict
    ), f'sureau_soil must be a Dictionary not a {type(sureau_clim)}'

    # Make sure that modeling_options is a dictionary
    assert isinstance(
        modeling_options, Dict
    ), f'modeling_options must be a dictionary not a {type(modeling_options)}'

    # nhours
    assert isinstance(nhours, int) | isinstance(
        nhours, np.ndarray
    ), 'nhours missing. Parameter must be a float or integer value'

    # Compute transpiration for sureau_veg ------------------------------------------

    if modeling_options['transpiration_model'] == 'granier':
        e_inst = sureau_veg['e_lim'] + sureau_veg['e_min']

        # Compute tleaf
        t_gbl_leaf = compute_tleaf(
            t_air=sureau_clim['Tair_mean'],
            par=sureau_clim['par'],
            potential_par=sureau_clim['potential_par'],
            wind_speed=sureau_clim['wind_speed'],
            relative_humidity=sureau_clim['rhair_mean'],
            e_inst=e_inst,
            psi_leaf=sureau_veg['psi_lsym'],
            leaf_size=50,
            leaf_angle=45,
            turn_off_eb=False,
            transpiration_model=modeling_options['transpiration_model'],
        )

        # Add params to dictionary
        sureau_veg['leaf_temperature'] = t_gbl_leaf['t_leaf']
        sureau_veg['g_bl'] = t_gbl_leaf['g_bl']
        sureau_veg['leaf_vpd'] = t_gbl_leaf['vpd_leaf']

        # Calculate e_bound
        sureau_veg['e_bound'] = calculate_ebound_granier(
            etp=sureau_clim['pet'], lai=sureau_veg['lai'], time_step=nhours
        )
